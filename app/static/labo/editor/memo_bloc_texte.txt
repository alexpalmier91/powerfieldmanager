MÃ‰MO â€” SYSTÃˆME TEXTE & TOOLBAR (ZenHub / LABO Editor)
ğŸ¯ Objectif global

Mettre en place un systÃ¨me de toolbar texte unique et rÃ©utilisable (police, taille, couleur, gras, italique, underline, transformâ€¦) utilisable par tous les futurs blocs texte :

Texte simple (single-line)

Paragraphe

Texte autour dâ€™un cercle

Texte suivant un chemin (path / plume)

Tout autre bloc texte futur

ğŸ‘‰ La toolbar ne dÃ©pend jamais du type de rendu (HTML, SVG, Canvas).
ğŸ‘‰ Chaque bloc texte implÃ©mente seulement une interface minimale (â€œTextHostâ€).

ğŸ§± Architecture des fichiers
Fichiers cÅ“ur (communs, rÃ©utilisables)

text_toolbar_tools.js
â†’ UI de la toolbar (boutons, popovers, Ã©vÃ©nements)

color_picker_tools.js
â†’ Color picker type Google (popover indÃ©pendant)

font_picker_tools.js
â†’ Font picker + resolveFontFamily + helpers

text_toolbar_bridge.js
â†’ Pont universel entre la toolbar et nâ€™importe quel bloc texte

Fichiers blocs texte

text_simple_tools.js

text_paragraph_tools.js

text_circle_tools.js

text_path_tools.js

etc.

Chaque bloc texte importe la toolbar via le bridge, jamais directement.

ğŸ”Œ Le concept clÃ© : TextToolbarBridge

La toolbar ne connaÃ®t pas le bloc texte.
Le bloc texte expose une interface minimale appelÃ©e ici TextHost.

CrÃ©ation du bridge
state.toolbar = TextToolbarBridge.createTextToolbarBridge({
  hostEl,
  textHost: { ... }
});

ğŸ“œ Interface TextHost (contrat obligatoire)

Chaque bloc texte doit fournir ces mÃ©thodes :

1ï¸âƒ£ getContext()

Retourne lâ€™Ã©tat actuel Ã  afficher dans la toolbar.

getContext: () => ({
  isVisible: true,
  anchorRect,
  hostRect,
  fonts,
  fontKey,
  currentFontKey,
  size,
  color,
  align,
  bold,
  italic,
  underline,
  transform,
})


âš ï¸ Aucune logique UI ici, uniquement des valeurs.

2ï¸âƒ£ onAction(action)

ReÃ§oit toutes les actions de la toolbar.

onAction({ type, value })


Types possibles :

font

size

color

bold

italic

underline

align

transform

ğŸ‘‰ La logique est toujours cÃ´tÃ© bloc texte.

3ï¸âƒ£ onBeforeOpenColorPicker()

âš ï¸ OBLIGATOIRE pour Ã©viter la perte de sÃ©lection

onBeforeOpenColorPicker: () => {
  if (!isEditing()) return;
  saveSelectionRange(editEl);
  highlightSavedSelection(editEl);
}

4ï¸âƒ£ onBeforeOpenFontPicker()

MÃªme principe que pour la couleur.

âœï¸ Gestion de la sÃ©lection texte (RÃˆGLES CRITIQUES)
Fonctions standard Ã  toujours utiliser

saveSelectionRange(editEl)

restoreSelectionRange(editEl)

highlightSavedSelection(editEl)

clearSelectionHighlight(editEl)

RÃ¨gles

Toujours sauvegarder la sÃ©lection AVANT lâ€™ouverture dâ€™un popover

Toujours restaurer la sÃ©lection AVANT dâ€™appliquer un style

Le popover ne doit jamais voler le focus

ğŸ¨ Couleur du texte (point sensible)
ProblÃ¨me rencontrÃ©

Perte dâ€™espaces

Spans imbriquÃ©s

SÃ©lections corrompues

Solution validÃ©e

Utiliser Range.extractContents()

Nettoyer les couleurs existantes

Re-wrapping propre

Ne jamais utiliser innerText pour reconstruire le texte

Fonctions clÃ©s

applyColorToSelection(editEl, color)

extractPlainPreserveSpaces(editEl)

âŒ Ne jamais faire .replace(/\s+/g, " ") aprÃ¨s une couleur

ğŸ”¤ RÃ©cupÃ©ration du texte (IMPORTANT)
âŒ Ã€ Ã©viter
edit.innerText.replace(/\s+/g, " ")

âœ… Ã€ utiliser
extractPlainPreserveSpaces(edit)


Cette fonction :

conserve les espaces

enlÃ¨ve uniquement :

ZWSP (\u200B)

retours ligne

ne casse pas les mots

ğŸ” Cycle de vie dâ€™un bloc texte
SÃ©lection

state.selectedId = id

toolbar.update()

Double clic

Passage en Ã©dition

Focus sur contentEditable

CrÃ©ation du listener selectionchange

Action toolbar

restoreSelectionRange

apply style

saveSelectionRange

update object (o.html, o.text)

render

DÃ©sÃ©lection

toolbar.closePopovers()

exitTextEdit(true)

ğŸ§  Principe clÃ© pour les futurs blocs (texte cercle / path)

La toolbar travaille TOUJOURS sur un contentEditable â€œsourceâ€

Le rendu (SVG textPath, canvasâ€¦) est une projection

Le style partiel est stockÃ© via :

html

ou runs[] (Ã©volution future)

La toolbar ne sait pas si le texte est droit, courbÃ© ou libre

ğŸ§ª Debug conseillÃ© (quand Ã§a dÃ©raille)
dbgChars("BEFORE", edit.textContent);
dbgChars("AFTER", edit.textContent);
console.log(edit.innerHTML);


Permet de dÃ©tecter :

NBSP

ZWSP

suppressions involontaires

âœ… RÃ¨gles dâ€™or (Ã  toujours respecter)

âŒ Pas de logique toolbar dans les blocs

âœ… 1 toolbar unique, branchÃ©e via bridge

âŒ Pas de innerText pour reconstruire le texte stylÃ©

âœ… Toujours sauver/restaurer la sÃ©lection

âœ… Toujours prÃ©server les espaces

âœ… Le rendu est indÃ©pendant de lâ€™Ã©dition

ğŸ§­ Vision long terme

Ce systÃ¨me permet :

dâ€™ajouter de nouveaux types de texte sans toucher Ã  la toolbar

dâ€™avoir un comportement cohÃ©rent partout

dâ€™Ã©voluer vers des styles riches (runs, SVG avancÃ©, PDF)